# 背景  
假设我们要开发一款游戏， 当然为了吸引更多的人玩， 游戏难度不能太大（让大家都没  
有信心了， 估计游戏也就没有前途了），但是也不能太简单（没有挑战性也不符合玩家的心  
理）。于是我们就可以采用这样一种处理策略： 为游戏设立等级，初级、中级、高级甚至有  
BT 级。 假设也是过关的游戏， 每个关卡都有一些怪物（ monster） 守着， 玩家要把这些怪物  
干掉才可以过关。 作为开发者， 我们就不得不创建怪物的类， 然后初级怪物、 中级怪物等都  
继承自怪物类（当然不同种类的则需要另创建类，但是模式相同）。在每个关卡， 我们都要  
创建怪物的实例，例如初级就创建初级怪物（ 有很多种类）、中级创建中级怪物等。可以想  
象在这个系统中， 将会有成千上万的怪物实例要创建， 问题是还要保证创建的时候不会出错：  
初级不能创建 BT 级的怪物（玩家就郁闷了，玩家一郁闷，游戏也就挂挂了），反之也不可以。  

AbstractFactory 模式就是用来解决这类问题的：要创建一组相关或者相互依赖的对象  

AbstractFactory 模式和 Factory 模式的区别:
- AbstractFactory 模式是为创建一组（ 有多类） 相关或依赖的对象提供创建接口  
- Factory 模式是为一类对象提供创建接口或延迟对象的创建到子类中实现
- AbstractFactory 模式通常都是使用 Factory 模式实现（如例程ConcreteFactory1）

测试程序中可以看到，当我们要创建一组对象（ ProductA1，ProductA2）的时候，只用维护一个创建对象（ConcreteFactory1）  
